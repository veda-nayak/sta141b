---
title: "Reading Solar Data -- Part 2"
author: "Veda Nayak"
date: "2025-04-16"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
dir = "C:/cygwin64/home/vedan/Code/sta141b/"
source(paste(dir, "/assignment1part2functions.R", sep = ""))

```

# Overview
The goal of this assignment is to extract information from the climate data in the .stat files and generate four tables.

- Monthly Statistics for Relative Humidity
    - 11 Columns: Month, Maximum, Minimum, Daily Average, DayTime Average, NightTime Average, Max Day, Max Hour, Min Day, Min Hour,Location
    - 12 Rows: One for each month
- Monthly Statistics for Solar Radiation
     - 7 Columns: Month, Direct Average, Direct Max, Direct Max Day, Diffuse Average, Global Average, Location
     - 12 Rows: One for each month
- Average Hourly Statistics for Opaque Sky Cover
    - 4 columns: Month, Hour, Temperature, Location
    - 288 Rows: One for each month * hours in a day
- Psychrometric Chart Data
  - 3 columns: Dewpoint, Dry Bulb Temperature, Location
  - The number of rows are dependent on the number of dewpoint-dryBulb combinations the average temperature was taken at. 
  
I also added a "location" column to each file to make it easier to orient the viewer / person working with the data.

# PART 2 

## Step 1: Extract lines of text corresponding to the tables
I first created functions that would help me extract the tables I needed (their respective lines). I created the following functions in this pursuit. 

- getBlocks: Creates blocks of text that start with " - " and end at the line before the next " - ".
- tableStarts: Uses the getBlocks() and findTitles() functionsinds the block indices corresponding to the start of the tables we are interested in.
- findTitles: Uses grepl() to checks if a given block corresponds to a table we are after.
- getTables: Uses the getBlocks() and tableStarts() functions to extract all the lines needed for the respective tables.

## Step 2: Extracting Desired Table Data from One Dataset and Transforming the Dataframe
I worked with the "USA_CA_UC-Davis-University.AP.720576_TMYx.2009-2023.stat" data. I made four functions to do this, one for each table. There was enough variability in the dataset that made me think that four functions would be best. 

- getAvgHourSkyCount: "Average Hourly Statistics for Opaque Sky Cover" dataframe generation
- getHumid: "Monthly Statistics for Relative Humidity" dataframe generation
- getPsyched: "Psychrometric Chart Data" dataframe generation
- getSolarRad: "Monthly Statistics for Solar Radiation" dataframe generation

The workflow for the *getHumid* and *getSolarRad* is as such:
1. Use getTables() to get a list of tables.
 2. Extract the table I was after. 
- Since the order of the tables was location specific on the document, and there was a consistant ordering of tables, getTables() outputs the files in this order: "Monthly Statistics for Relative Humidity", "Monthly Statistics for Solar Radiation", "Average Hourly Statistics for Opaque Sky Cover", "Psychrometric Chart Data". I extracted the correct table based on the numerical positioning in the tables list. 
 3. Transfer the lines to a text connection to make it workable when using the read.delim() function.
 4. Use read.delim() to import the lines into a dataframe. The lines use tab separation.
 
 # FINISH

The workflow for the *getPsyched* and *getAvgHourSkyCount* is as such:
 1. Use getTables() to get a list of tables.
 2. Extract the table I was after. 
- Since the order of the tables was location specific on the document, and there was a consistant ordering of tables, getTables() outputs the files in this order: "Monthly Statistics for Relative Humidity", "Monthly Statistics for Solar Radiation", "Average Hourly Statistics for Opaque Sky Cover", "Psychrometric Chart Data". I extracted the correct table based on the numerical positioning in the tables list. 
 3. Transfer the lines to a text connection to make it workable when using the read.delim() function.
 4. Use read.delim() to import the lines into a dataframe. The lines use tab separation.
 5. Remove extra lines and rename the id column.
 6. Use  melt() from the reshape2 library to move the columns into rows
 7. Final dataframe cleanup (removing whitespace, etc.)
 

## Step 3: Implimenting the functions across all files
I put all four dataframe generation functions into a function that would output a list of dataframes to make it easier to apply across a list of files. 

- getDataframes: Generate a list of the four data frames I am interested in for this assignment. 

```{r echo=TRUE}
knitr::opts_chunk$set(include = FALSE)
dir = "C:/cygwin64/home/vedan/Code/sta141b/"
source(paste(dir, "/assignment1part2functions.R", sep = ""))

files <- list.files(path="C:/cygwin64/home/vedan/Code/sta141b/Solar1/unzip", pattern="stat")
df_list = lapply(files, getDataframes)
getDataframes(files[1])
yosemite_humid = df_list[[1]][[1]]
yosemite_solar_rad = df_list[[1]][[2]]
yosemite_sky_cov = df_list[[1]][[3]]
yosemite_psych = df_list[[1]][[4]]

yosemite_humid

# traceback(x = NULL, max.lines = getOption("deparse.max.lines"))

```

## Generated Dataframes

Since I developed the functions using the Davis data, I wanted to validate my results using data from another location. I chose to look at the Yosemite dataset for validation. 

Yosemite - Monthly Statistics for Relative Humidity:
```{r echo=TRUE}
yosemite_humid
```


Yosemite - Monthly Statistics for Relative Solar Radiation:
```{r echo=TRUE}
yosemite_solar_rad
```


Yosemite - Average Hourly Statistics for Opaque Sky Cover:
```{r echo=TRUE}
head(yosemite_sky_cov)
tail(yosemite_sky_cov)
```

Yosemite - Psychrometric Chart Data

```{r echo=TRUE}
yosemite_psych
```



# Validation
- Class of dataframe
- Converting character --> numerical if applicable

## Monthly Statistics for Relative Humidity

### Check Dataframe and Column Class Expectations

*Check if the output is a dataframe:* 

```{r}
class(yosemite_humid)
```
The output is a dataframe. 


*Check if dimensions align with expectations:*
```{r, Yosemite Monthly Statistics for Relative Humidity}
dim(yosemite_humid)
```
We expected an 12 x 11 dataframe, so this dataframe aligns with our expectations. 


*Check Column Type*
I wanted to confirm that the month and location were a character type vectors and that all others were integer vectors. 

```{r}
sapply(yosemite_humid, function(x) class(x[c(1:dim(yosemite_humid)[2])]))
```
All columns have a class consistant with what we expected

### Graph Data to Gauge Validity

```{r}
davis_humid = df_list[[5]][[1]]

library(tidyverse)

# make a long form of the data to see differences between the max and mins across the months
# yes this does negate some of the data manipulation I did in my functions
long_humidity_yosemite <- yosemite_humid %>% pivot_longer(!c("Month", "location"), names_to = "measurement", values_to = "value")

long_humidity_yosemite_no_hour <- long_humidity_yosemite %>% filter(measurement != 'Max_Day') %>% filter(measurement != 'Min_Day') %>% filter(measurement != 'Min_Hour') %>% filter(measurement != 'Max_Hour')

yosemite_humid_graph_humidity_readings = ggplot(long_humidity_yosemite_no_hour, aes(x = Month,
                                                              y = value,
                                                              color = measurement, 
                                                              group = measurement)) +
                      geom_point() +
                      geom_line()+
                      labs(title = "Yosemite - Monthly Statistics for Relative Humidity",
                           x = "Month",
                           y = "Percent Humidity", 
                           fill = 'Measurement') + 
                      theme_minimal() 

yosemite_humid_graph_humidity_readings

```
The maximum humidity is consistently greater than the minimum humidity, which is logical. 
The daily average seems to sit right in the middle of the DayTime and NightTime averages, which is logical. 

```{r}

yosemite_humid_only_hour <- yosemite_humid[c('Month', 'Max_Hour', 'Min_Hour')]

long_humidity_yosemite_only_hour <- yosemite_humid_only_hour %>% pivot_longer(!c("Month"), names_to = "measurement", values_to = "value")

yosemite_humid_graph_hour_readings = ggplot(long_humidity_yosemite_only_hour, aes(x = Month,
                                                              y = value,
                                                              color = measurement, 
                                                              group = measurement)) +
                      geom_point() +
                      geom_line()+
                      labs(title = "Yosemite - Average Hour Where the Daily Max and Min Humidity was Observed",
                           x = "Month",
                           y = "Hour", 
                           fill = 'Corresponding Hour') + 
                      theme_minimal() 

yosemite_humid_graph_hour_readings
```
The hour that corresponds to the maximum humidity is at night. This is consistent with the data in the previous graph showing that the nighttime average was higher than the daytime average. 


## Monthly Statistics for Relative Solar Radiation

*Check if the output is a dataframe:* 

```{r}
class(yosemite_humid)
```
The output is a dataframe. 


*Check if dimensions align with expectations:*
```{r}
dim(yosemite_solar_rad)
```
We expected an 12 x 7 dataframe, so this dataframe aligns with our expectations. 

*Check Column Type*
I wanted to confirm that the month and location were a character type vectors and that all others were integer vectors. 

```{r}
sapply(yosemite_humid, function(x) class(x[c(1:dim(yosemite_humid)[2])]))
```
All columns have a class consistent with what we expected.

### Graph Data to Gauge Validity


## Average Hourly Statistics for Opaque Sky Cover
*Check if the output is a dataframe:* 

```{r}
class(yosemite_humid)
```
The output is a dataframe. 


*Check if dimensions align with expectations:*
```{r}
dim(yosemite_sky_cov)
```
We expected an 288 x 4 dataframe, so this dataframe aligns with our expectations. 

*Check Column Type*
I wanted to confirm that the month and location were a character type vectors and that all others were integer vectors. 

```{r}
sapply(yosemite_humid, function(x) class(x[c(1:dim(yosemite_humid)[2])]))
```
All columns have a class consistent with what we expected.

### Graph Data to Gauge Validity

I thought comparing the sky coverage data to Davis would help contextualize my results. 
```{r}
davis_sky_cov = df_list[[5]][[3]]

yosemite_davis_sky_cov <- bind_rows(yosemite_sky_cov, davis_sky_cov)

yosemite_davis_sky_cov_graph = ggplot(yosemite_davis_sky_cov, aes(x = month, 
                                                            y = percent_covered, 
                                                            color = location)) +
                      geom_point() +
                      labs(title = "Yosemite: Average Hourly Statistics for Opaque Sky Cover",
                           x = "Month",
                           y = "Opaque Sky Cover Percentage") + 
                      theme_minimal() +
                      geom_smooth()

yosemite_davis_sky_cov_graph
```
Yosemite consistently has higher sky coverage percentages as compared to Davis. This makes sense since Yosemite experiences more snow and rain than Davis does, especially in the summer months. 



## Psychrometric Chart Data

*Check if the output is a dataframe:* 

```{r}
class(yosemite_humid)
```
The output is a dataframe. 


*Check if dimensions align with expectations:*
```{r}
dim(yosemite_psych)
```
We expected an 40 x 4 dataframe, so this dataframe aligns with our expectations. 

*Check Column Type*
I wanted to confirm that the month and location were a character type vectors, the temperature was a numeric vector, and that the dewpoint and dry_bulb columns were charecter / factor vectors. 

```{r}
sapply(yosemite_psych, function(x) class(x[c(1:dim(yosemite_psych)[2])]))
```
All columns have a class consistent with what we expected

### Graph Data to Gauge Validity


# Acknowledgments
[Step 2 - Step 6, transforming the data: melt() function in 'reshape2' library]("https://stackoverflow.com/questions/32390886/i-want-to-turn-column-names-into-an-identifying-column-in-r")
[Step 2: Removeing whitespace in the Relative Humidity dataframe]("https://stackoverflow.com/questions/34591329/remove-white-space-from-a-data-frame-column-and-add-path")
[Validation - Connecting points in ggplot]('https://stackoverflow.com/questions/8592585/combine-points-with-lines-with-ggplot2')

# Questions
- How can I make the psychometric data more general when there are missing values in the table
- Why is my output not showing cry

# Notes for class
- Write the functions in a separate file
- Write application of code w/ echo = TRUE in markdown
- Find Globals could show you where there is a variable you're using but isn't defined, do merge = false


